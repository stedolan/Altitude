The Altitude Virtual Machine


Some defintions:

"Userspace" and "user objects" refers to objects in the program being run under Altitude (the user program), so, for instance, user source code is the source code of the user program, a user type is a type used in the user program (which often won't exist in Altitude's source), a user int is an int as defined in the user program (in physical memory, it may not be represented as an "int" in Altitude. Altitude enforces that user ints are 32-bit signed, no matter what the size of an int on the platform altitude is compiled).

"System" is the opposite, and refers to things defined in Altitude's source. For instance, user ints aren't necessarily represented as system ints. A system call is a call made in user code to a function defined internally to Altitude, not in user code. For instance, user-space "malloc" is a system call.

The "program" is all of the parts of the user program that are known at compile time and don't change. For instance, functions (and their code), types, global variables (their declarations and initialisers but not necessarily their runtime values) are part of the program.

A "location" is a reference to user source. It contains a filename, line number, byte position in the file, and reference to the enclosing function. Any subset of these may be present (e.g. sometimes it's difficult or impossible to give an exact line number, sometimes things happen outside any function, etc.).

A "blob" is a piece of memory guaranteed to be contiguous by C. The C standard generally refers to these as "objects", but we've chosen the term "blob" as it's less confusing to those who are used to object-oriented programming (For instance, OO programmers might consider each element of an array an "object", while the entire array is one "blob" in Altitude). Local, global and function-static variables each have a single associated blob, and new blobs can be created at any time by a call to "malloc".

"Sexpcode" is the s-expression-based, Lisp-like form of a C program that the VM receives from the Altitude compiler. A "sexp", is a single, possibly nested, s-expression as used to build sexpcode.

A "stack frame" of a user-function is the activation record for that function and contains the values of the functions formal arguments and local variables. The name "stack frame" is chosen to be consistent with other systems, in Altitude they aren't actually stored on a physical memory stack.

When this document speaks about "types", or "the type system", it is talking not about the C type system, but the Altitude one. These differ in a number of small, mostly irrelevant ways. Generally, the differences are that C defines some types to be different but compatible, while Altitude collapses these definitions into one. For instance, a function argument of type int[10] is just passed as a pointer in C, and it is legal to pass to a function that requires an int[10] an int[15] (or even an int[5], although that often causes bad things). In Altitude, there are no array types in function parameters, just pointers. Another difference is that Altitude conflates "signed char" and plain "char", which is not the case in C (C says "char" is a distinct type from both signed and unsigned char, but must be completely equivalent to an implementation-specified one of them. Yippee.).


Overall Structure

By the time the VM gets a user program, it has already been compiled into sexpcode. The level of abstraction of sexpcode is like a type-aware assembly language. For instance, loops and if statements have been compiled away to explicit "goto"s, but operations like sizeof and finding a field of a structure given a pointer are left in symbolic form, and haven't been compiled down to constants or pointer arithmetic.

Sexpcode has a simple form: Each sexp has a tag, chosen from a fixed set defined by an enum in sexp.h, and any number of children. Each child is either a string, an integer, or a sexp. Children of a sexp are represented as "struct sexp_element", which contains a union tagged with what type of element it is. So, it is common to see code like:
        if (sexp->nelems == 1 &&
            sexp->elems[0].type == ST_SEXP){
          struct sexp* only_child = sexp->elems[0].data.sexp;
        }

The sexpcode is then passed to the function "compile" (in bytecode.c) which generates a struct program. The top-level objects are types, global variables, and functions. They are processed in that order, as variables may refer to types and functions may refer to either variables or types. "compile" separates out the three categories, then passes the types to "build_typemap" (the "typemap" is explained below)












Pointers and the Typemap

To explain some of the oddities of C and how we handle them, I'll refer to Java as an example of a language which is at least superficially similar to C, but does these things differently.

In Java, a pointer (reference) always points to an entire blob (object). You can't point to the "foo" field of an object in Java. (The "foo" field may well be an object reference, but that's entirely different. You can't refer to the "foo" field itself in a way that you keep pointing to it even though it may change). In C, however, anything that you can access (and many things you can't) can be pointed at.

So, a Java reference carries a fixed, small set of assumptions. By having a Java reference, the programmer is assuming that there is an object of the referred-to type beginning at the memory address given by the reference. These are enforced by the implementation with a combination of compile-time typechecking and garbage collection.

A C pointer is entirely different, and the set of assumptions made by the programmer about the pointer is often not completely known at compile-time. First of all, the mere act of having a pointer does not make any assumptions about memory (unlike in Java). It is perfectly OK in C to have a pointer such as "&(((int*)NULL)[5])", pointing at the 6th element of a null array, about which no assumptions at all can be made.

Rather, the assumptions in C are made by reading from or writing to the memory pointed to by the pointer. The first and most basic assumption made when reading or writing is that the pointer lies within the boundaries of an allocated, un-freed blob (blobs are allocated as part of a function's stack frame or by malloc() and freed upon return or free()). When this assumption is violated, the behaviour is undefined. Typical behaviours are a crash or silent corruption of memory.

Unlike Java, these assumptions are not required to be checked at runtime by the implementation. As with the other assumptions that an implementation need not check, Altitude makes an effort to check it, and report an informative error message if it doesn't hold.

There are various other tools that check this assumption to varying degrees of accuracy, through instrumentation of source code (e.g. GNU gcc's "mudflap") or analysis of dynamically running machine code (e.g. valgrind's "memcheck"). Since these tools operate on compiled code, they often have some information loss. For instance, valgrind can't detect when pointers to stack variables go off the end of their blob and access other stack variables instead, as it just sees the stack as an opaque chunk of memory and sees the invalid access as valid, without realising it's to a different part of the stack.

Still, tools other than Altitude can check this assumption to a high degree of accuracy, without Altitude's performance penalty.

Altitude's power comes from being able to check other, more subtle, assumptions. There are other assumptions in C about memory access. These assumptions have a lesser penalty: when they don't hold, the program may still work and only the value of a particular expression is undefined. A standard example is reading from uninitialised memory (which the likes of valgrind can check), or reading from a piece of memory used as structure padding (which the likes of valgrind can't check). It is incorrect to abandon the execution of a program when one of these assumptions is violated. Theoretically, a C program could create an array, put a valid value in its first element, copy the entire array to a new location (so all but the first element cause reads and writes of undefined values), and then perform some action on the first element.

So, Altitude doesn't cause an error upon such accesses. Instead, if an access is shown to give an undefined result, the value returned is marked as "invalid". Invalidness propagates through the program, and a warning is printed if an invalid value is used for anything suspicious (allocating an invalid amount of memory, outputting and invalid value, dereferencing an invalid pointer, etc). Configurably, the warning may also be printed for every operation involving an invalid value, although this may be a bit extreme as many valid operations can be performed involving some internal manipulation of invalid values (e.g. the array scenario above). As a simple future extension, users will be able to configure this warning level on a per-function basis, to inform Altitude that a given function does something unusual but that the user trusts its implementation.

So, what are these subtle assumptions that Altitude can check but other systems can't?

For these examples, assume the following is defined in user-code:

  union U{
    int num;
    char* str;
    void* ptr;
  };
  struct S;
  struct S{
    struct S* next;
    int value;
  };

  struct A{
    struct S st;
    union U un;
    char ch;
  };
  struct B{
    struct S st;
    int num;
  };


C makes a number of guarantees about structs and unions. In particular, the first element of a struct is guaranteed to start at the same address as the struct itself, and all elements of the union start at the same address.

Consider an object whose type is "union U". If the "num" element was last assigned to, and the "str" element is read, Altitude will mark the result as invalid. If the "str" element was last assigned to, and the "ptr" element is read, Altitude will *not* mark the result as invalid, as unions are guaranteed to put all elements at the same address and pointers are guaranteed to be convertible to each other without changing the in-memory representation. Likewise, if the ptr element is assigned to, and the str element is read, Altitude will return "ptr" as "str" without complaint, but will maintain the type of "ptr", and will cause an warning if a user accesses the pointer as if it were a string, or passes it to a string-requiring function like strtol.

This example shows that "invalidness" is a deeper concept than one-bit-per-memory-location (as used by tools which detect uninitialised memory accesses), as a given piece of memory can easily be valid as one type and invalid as another.

A more interesting example: suppose a function takes a struct A* pa. It casts it to a struct B*, so it now has both pa and pb which point to the same location. Further suppose that this piece of memory was previously used to store a struct A, so all the fields of *pa are valid (and let's say the union stored an int). Finally, suppose that the blob of memory pointed to by pa or pb is big enough to hold either a struct A or a struct B.

The function can happily read and write to *pa's fields. Furthermore, it can validly read and write to pb->st.next and pb->st.value, as pb->st is guaranteed to be the same as pa->st. Reading from pb->num will not necessarily return pa->un.num as the implementation is allowed to have different amounts of padding between elements of the two structs. The read from pb->num won't crash the program, but may produce an invalid value.

Suppose then, that the function passes &pb->num to another function. This other function gets an int* argument, called i. Reading from *i will succeed but produce an invalid value for the reasons above. Writing to *i will have a very interesting effect: it will succeed, but it will invalidate pa->un and pa->ch!

This is because the program can't rely on a particular layout of structures (it is chosen arbitrarily by the compiler, with certain restrictions). So, it is possible that in a conforming C implementation, the write to *i will overwrite all or part of pa->un or even all or part of pa->ch! (Unusual layouts like these can happen if a compiler sees two similar structures and decides to pack one tightly for optimal space usage, and pad one generously to aligned boundaries for optimal speed). Altitude will detect that the write to *i invalidated pa->ch even though, in Altitude's layout, the objects don't overlap.

In C, a write to a memory location can invalidate the contents of an entirely different memory location (simply because the program couldn't possibly have known the locations were non-overlapping when the programmer wrote it), and Altitude can detect this sort of bug even though the invalidated memory location is not changed by the invalidating write!

As it happens, pa->ch won't be changed by the write since Altitude lays out pa->ch after the address pointed to by pb->num, but Altitude can also detect that it is possible for a conforming implementation of C to overlap them, and so invalidates pa->ch.

This is what makes pointers in Altitude interesting: they carry information not just about what they point to, but what could be affected by a write through them (which may be much larger than their target). Messages are generated not only from inconsistencies in the program, but also from conditions that could cause inconsistencies in alternative implementations of C.

To bring it back to the Java comparison: the int pointer i has more built-in assumptions than "there is an int at this memory address". It contains assumptions about the layout of memory around the int ("there is a struct B containing this memory address"). The assumptions for a particular pointer don't hold consistently, as in Java. It is merely required that for any set of assumptions active during a memory read, the last write to that piece of memory was working under the same assumptions.

