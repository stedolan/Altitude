\documentclass[a4paper]{report}

\begin{document}

\tableofcontents

\chapter{Introduction}

\section{What this is}
Altitude is our reversible interpreter for the C programming language. The goal of the project is to build a teaching environment which will provide a safety net for C programmers, consisting of a minimal development environment with extensive debugging support. The various nooks and crannies of C are hard to learn for a novice programmer.
\section{Why this is cool}
There are nigh-innumerable ways to shoot oneself in the foot when programming in C. For starters, thereâ€™s subtle bugs like taking the address of a stack variable and returning it, or double-freeing some memory. Both of these will often work depending on things like underlying C library, compiler optimisation levels, whether any other functions are called before the invalid pointer is dereferenced (who knows, the data may still happen to be on the stack). The seemingly random nature of these bugs makes them very difficult to diagnose for an inexperienced programmer. By maintaining state for every allocated object, these bugs could be detected early and reliably during the execution of the program. Another class of bug is the code which works totally reliably on a given system but accidentally depends on some platform-specific behaviour and is in fact invalid as ISO C code. Examples of this include indexing into an array with a char variable (as the signedness of char is implementation-specified).
\par
This project aims to prevent a significant amount of bugs derived from a novice's lack of in-depth understanding of how C works. There are many cases where even experienced users are driven to frustration by subtle differences in how code is handled, and nobody should have to know exactly how every compiler their program may ever be run on will handle their code. To this end, our aims are to prevent implementation-specific code from being written, and to provide reasons why any given error is, in fact, an error.
\section{Why this is hard}

The specification of the C language is much less defined than, say, Java or Python. Many questionable constructs, instead of causing an error, may or may not cause the program to fail. Equally many questionable constructs are entirely valid in C and give well-defined results.

The vagueness of the specified behaviour of C in many areas is mostly due to a concern for efficiency. Imagine the efficiency of the code an optimiser could produce if it were allowed, even encouraged, to break in edge cases! It also means that the usual approach to some unknown facet of the language (write a small test-case, run it, see what happens) is entirely meaningless in C, as what happens may vary from compiler to compiler if it invokes some of the undefined parts of the C standard.

\subsection{C's Taxonomy of Failure}
C code can fail in various different ways. There is no uniform error reporting for this, in fact errors aren't necessarily detected. Again, this is for efficiency. Accurate programmers can write code that runs without wasting time on checking, say, array bounds.

The types of unusual behaviour for a C program, as defined in the Standard, are:
\begin{description}
\item[Implementation-defined behaviour] This is some aspect of the language which the C standard leaves up to the particular implementation, with the proviso that each implementation must make a definite, documented choice. This is usually used in cases where there are multiple choices, and which is more efficient or easier to implement depends on historical baggage, or the underlying hardware. A typical example is whether or not the ``char'' type is signed.

Programs are often targetted to a particular platform, in which case relying on implementation-defined behaviour is valid. However, portable programs must not rely on it.

\item[Unspecified behaviour] This means that an implementation of C is free to choose from a well-defined set of choices. It doesn't have to document its choice, nor must it be consistent in choosing. This is usually used to give extra latitude for program transformation to optimising compilers. If a compiler knows in advance that it is allowed to make certain changes, it needn't bother to prove that the change won't affect the semantics of the program. A typical example is the order of evaluation of function arguments.

Programs can invoke unspecified behaviour (it's generally hard to avoid), but should produce the same results whichever choice the C implementation makes.

\item[Undefined behaviour] This means that anything can happen, according to a famous Usenet post it may cause ``demons to fly up your nose''. This is a bug in a C program. Since C programs do no error-checking other than that explicity written by the programmer, undefined behaviour can do anything. Common behaviours are program termination by segfault or similar, and silent data corruption.

Programs must avoid undefined behaviour, a program whose function is unknown is not particularly useful. Most bugs in C programs manifest themselves as undefined behaviour resulting in abnormal termination or segfaults.
\end{description}

Altitude is designed to show up any bugs in the program, and give the user an opportunity to understand and debug them. To this end, it tries to be as evil as possible in implementation-defined and unspecified behaviour (so that the bugs are more likely to appear), and as nice as possible in undefined behaviour (typically by giving a very detailed description of the undefined behaviour, rather than ``Segmentation fault.''.

An example of being-evil is Altitude's choice that ``char'' is signed. This will break programs that naively try to use characters as array indices, to, say, count character frequencies.


\section{Structure}
\subsection{Compiler}
\subsection{Virtual Machine Model}
\subsubsection{Layers}
There are two logically separate layers to the VM's memory-checking.
\subsubsection{Blobs}
Each chunk of memory that is allocated by the program is a blob. There is a blob per global variable, one per local variable, and one per malloc(). We keep track of when blobs are created and destroyed, and we keep track of the particular blob to which each pointer points. Pointer arithmetic does not allow a pointer to jump from blob to blob (this is the case in working C programs. This failing to be the case is a very common source of bugs).
\par
A short summary of the structure of a blob:
\begin{itemize}
\item a piece of memory with an address and a length
\item one of 3 states:
  \begin{itemize}
  \item uninitialised (the initial state, contains garbage, writes are OK, reads are probably errors)
  \item valid (contains a single object, reads OK, writes OK)
  \item freed (already been free()d or gone out of scope, reads errors, writes errors) 
  \end{itemize}
\end{itemize}
\subsubsection{Objects}
Within a blob, we keep track of the type of whatever was stored there last. For instance, if you allocate a blob of memory via malloc(), it is perfectly fine in C to use it for a while to store struct foo and then later to store a struct bar. However, it is an error to read from it as if it were a struct bar while it in fact contains a struct foo. You can't tell that a program isn't going to do these kind of things by simply type-checking it in C as you can in other languages, but we can check whether they happen at run-time. 
\par
A short summary of the structure of an object:
\begin{itemize}
\item a type - this is a C type like int, struct foo, char*, etc. 
\item a garbage flag which says that the object is
  \begin{itemize}
  \item garbage (generally means uninitialised data, reads probably errors, writes OK) 
  \item not garbage (reads and writes are OK) 
  \end{itemize}
\item compound objects like structs, unions or arrays will have a garbage bit for each element. 
\end{itemize}
The sort of errors that the blob-checking code catches are errors which might cause a segfault or the like. They are generally invalid and always bugs. However, it is possible for the object-checking code to mark things as wrong incorrectly.
\par
\subsubsection{Pointers}
Pointers in the context of the VM are more than just the C pointers they represent. They have information stored with them to aid in the debugging of pointer operations performed by the interpreted program.
\par
The internal structure of a pointer in the context of the virtual machine is;
\begin{itemize}
\item the blob they point to 
\item a "path", which describes the part of the blob that they refer to (e.g. "the foo member of the 4th struct in the array stored in this blob"
\end{itemize}
\subsubsection{Error Checking}
One of the cool features of this VM is the error-checking model. Every instruction that is executed by the VM is checked both for valid memory addressing (the memory was previously allocated) and for valid typing (you didn't try to read a char from what you just set to int). 
\subsection{Patches}
The "reversible" part means we have to be able to go back to any earlier stage reasonably efficiently, which is going to make for some very interesting data structures.
\par
The state of the VM is all the information pertaining to the running program, such as the call stack, values of the local variables, values of global variables, and any data allocated on the heap.
\par
We need to be able to switch from state to state while still maintaining enough information to go back to earlier ones. One point to note is that we needn't store every state, it is possible to just store states every so often as if we can restore an early state we can run forward from that point to get later ones.
\par
We can store this information as a series of patches. A patch from state s1 to s2 is enough information such that, given all the information we have at state s1, we could build state s2, and given the information at state s2 we could build s1.
\par
A patch could be represented as "From s1 to s2, these variables were changed from "some values" to "some other values", "these bits of memory" were allocated and had "these bits of data" stored in them, "these bits of memory" were freed and had "these bits of data" at the time they were freed".
\par
The point here is, a patch from s1 to s2 only stores the data that changed between states s1 and s2. This means we can run the VM in a reasonable amount of ram.
\par
Patches, as described, have some interesting structure. Firstly, consider merging two patches. If we have two patches to the program state which come one after the other, we can merge them into one big patch from the original state into the newest one.
\par
Secondly, consider the null patch. That is, the patch which says "nothing changed". Now consider the initial state, that is, the state of the VM just upon entry to main(). This will be referred to as the "base state". The state of the program can be considered as a big patch against the base state. This is not just an idle observation, it means we can actually store the current state of the running program as just another patch, and we need no special data structures for it.
\par
Suppose we want to save a checkpoint to return to during the running of the program (it doesn't really matter where we do this, every N instructions would be reasonable). We can take the patch representing the current state, add it to a list of checkpoints, and set our "current state" patch to the null patch (it is now a patch against the most recently saved checkpoint). Thus, saving snapshots can be done really quickly.
\par
That works fine for writes, but for reads we're going to need to know the current value of the variables. If we just have access to a list of differences from the previous state, we'd have to work backwards through the checkpoint list to get the actual value of the variable. So, in parallel we maintain another "current state" patch, representing the current state of all the program's variables. We should maintain the property that merging the checkpoint list yields the current state (i.e. following the history from the beginning will leave us where we are now).
\par
Stepping backward means reversing some checkpoint patches, stepping forwards means applying them again. With some relatively simple algorithms, we can get a lot of behaviour "for free".
\par
For those who care (probably just me for now :P): patches form a group, in the abstract algebra sense. We have an associative operation (merging), an identity (the null patch), and an inverse (reversing the patch).
\subsubsection{Merging patches}
One necessary part is an algorithm to merge patches. Here's a rough pseudo-pseudo-code version of it:
\par
Patches consist of a set of variables, saying for each variable whether it was created (allocated) by this patch, destroyed (freed), or changed value.
\par
To merge two patches p1 and p2, then for each variable in either p1 or p2:
\par
\begin{enumerate}
\item If it only appears in p1 or p2, then it should appear like that in the merged patch.
\item If it was created in p1 and modified in p2, then it should appear as created, with the modified value, in the merged patch.
\item If it was modified in p1 and destroyed in p2, then it should appear as destroyed, with the old value, in the merged patch.
\item If it was modified in p1 and modified in p2, then it should appear as modified, from the oldest to the newest value, in the merged patch. 
\end{enumerate}
\par
The other cases are impossible (can't be modified before being created, etc). 
\subsection{User interface}

\input{compiler.tex}
\input{vmmodel.tex}
\input{patches.tex}
\input{ui.tex}

\appendix

\input{sexpformat.tex}
\input{instructions.tex}


\end{document}
