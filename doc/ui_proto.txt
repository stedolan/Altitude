Okay, so - the following is the protocol used by the UI when interacting with the VM as I see it. All commands and data are passed between the processes on stdin/stdout.


-- STARTUP --

User starts by selecting a C source code file. This file is passed to altitude as an argument:

UI exec's new process: "altitude code/test/test.c" (maybe we use a switch or something, not important until it's written)

At this point, altitude should parse/convert to bytecode and sit and wait - we want to set breakpoints etc. before running the code.


-- COMMANDS --

When we want to run forward to the next breakpoint, we send 'run':

[UI >> Altitude]
run

When we want to run backwards to the prvious breakpoint, we 'runback'

[UI >> Altitude]
runback

When we want to set a breakpoint, we use 'set' followed by a line number:

[UI >> Altitude]
set #LINE_NO

Similar to unset a breakpoint:

[UI >> Altitude]
unset #LINE_NO

To reset the program, i.e. jump to the start and wait, we use 'restart':

[UI >> Altitude]
restart

To get a dump of variables in scope, we use 'view':

[UI >> Altitude]
view

This should return variable list in the following format:

var_list := var [newline var]

newline := \n | \r | \r\n

var := prim_type var_name value

prim_type := char | int | ... allllllll the other varitions of (un)signed long long / short int

value := any single char for a char | any integer for an int (or one of the variations)

/*FIXME*/ That's just primite types... structs, unions and arrays are a whole other kettle of text.

-- ERRORS & WARNINGS --

Errors and warnings are passed from altitude on stderr.

They take the form:
[Altitude >> UI]

[errno] message

message may contain a reference in the form @filename:lineno:byteoffset

Altitude will display this on its error console, and if it is a crash-worthy error, the program will alert the user explicitly.